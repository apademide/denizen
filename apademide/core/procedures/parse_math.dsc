# Prepares a formula for use by other procs
# It replaces various text to handle multiple notations for the same operatiosn
# and trim spaces
apa_core_proc_math_formula_prepare:
  type: procedure
  debug: false
  definitions: FORMULA
  script:
    # # Converts ([{}]) to parenthesis
    # - define FORMULA <[FORMULA].replace_text[<&lb>].with[(].replace_text[<&rb>].with[)].replace_text[<&lc>].with[(].replace_text[<&rc>].with[)]>
    # # Converts comma to dots and remove spaces
    # - define FORMULA '<[FORMULA].replace_text[,].with[.].replace_text[ ]>'
    # # Converts all types of dashes to the normal one (minus sign)
    # - define FORMULA <[FORMULA].replace_text[–].with[-].replace_text[—].with[-]>
    # # Converts all possible multiplicators to * (equations aren't supported so x is *) and ÷ to /
    # - define FORMULA <[FORMULA].replace_text[·].with[*].replace_text[x].with[*].replace_text[×].with[*].replace_text[÷].with[/]>
    # # Converts various notations of square roots to r and ^ powers to p
    # - define FORMULA <[FORMULA].replace_text[sqrt].with[r].replace_text[_].with[r].replace_text[^].with[p]>
    # # Handles pi
    # # Replaces by |3.14…| instead of 3.14… to handle 3pi formats without the * between (3 * pi)
    # - define FORMULA <[FORMULA].replace_text[pi].with[|<util.pi>|].replace_text[π].with[|<util.pi>|]>

    # Inline version of all the above define commands
    - define FORMULA '<[FORMULA].replace_text[<&lb>].with[(].replace_text[<&rb>].with[)].replace_text[<&lc>].with[(].replace_text[<&rc>].with[)].replace_text[,].with[.].replace_text[ ].replace_text[–].with[-].replace_text[—].with[-].replace_text[·].with[*].replace_text[x].with[*].replace_text[×].with[*].replace_text[÷].with[/].replace_text[sqrt].with[r].replace_text[^].with[p].replace_text[pi].with[|<util.pi>|].replace_text[π].with[|<util.pi>|]>'

    - definemap RESULT:
        OK: true
        RESULT: <[FORMULA]>
    - determine <[RESULT]>

# Split operators to get a list of all the formula's elements
# Must be a ready to use formula prepared with apa_core_proc_math_formula_prepare
apa_core_proc_math_formula_split:
  type: procedure
  debug: false
  definitions: INPUT
  data:
    operators:
      - sin
      - tan
      - cos
      - p
      - r
      - /
      - *
      - -
      - +
      - )
      - (
  script:
    - define MAP <[INPUT].proc[apa_core_proc_math_formula_prepare]>
    - if !<[MAP.OK]>:
      - definemap RESULT:
          OK: false
          MESSAGE: <[MAP.MESSAGE]>
      - determine <[RESULT]>
    - define FORMULA <[MAP.RESULT]>

    # Get all operators (including parenthesis)
    - define OPERATORS <script.data_key[DATA.OPERATORS]>

    # Loop through every operator
    - foreach <[OPERATORS]> as:OP:
      # Replace all operators by themselve surrounded by pipes to listify the element
      - define FORMULA <[FORMULA].replace_text[<[OP]>].with[|<[OP]>|]>
    # Deduplicates pipes generated by following operators (i.e multiplying a parenthesis' content) and split pipes
    - define FORMULA <[FORMULA].replace_text[||].with[|].split[|]>

    - define NEW_FORMULA <list>
    - define LAST_WAS_CLOSING false
    - define NEXT_HAS_SIGN false
    - define SIGN <empty>
    # New loop to handle negative numbers and numbers next to parenthesis
    - foreach <[FORMULA]> as:EL:

      # If we set NEXT_HAS_SIGN to true during the previous round
      - if <[NEXT_HAS_SIGN]>:
        # If the current value is a decimal, we combine it with its sign
        - if <[EL].is_decimal>:
          - define NEW_FORMULA:->:<[SIGN]><[EL]>
          - define NEXT_HAS_SIGN false
          - foreach next
        # If it's not a decimal, it means there are too many following operators
        - definemap RESULT:
            OK: false
            MESSAGE: Too many operators following each other.
        - determine <[RESULT]>

      # If the previous value in the loop was a closing parenthesis…
      - if <[LAST_WAS_CLOSING]>:
        # … we reset the value
        - define LAST_WAS_CLOSING false
        # If the current element is a "double input operator", we simply add it
        - if <list[*|/|+|-|^|p].contains[<[EL]>]>:
          - define NEW_FORMULA:->:<[EL]>
          - foreach next
        # But if that's not the case, we apply the rule saying that 2 elements
        # next to each other without an operator are mulitplied
        # > i.e. #(#),  (#)(#) becomes
        # >      #*(#), (#)*(#)
        - define NEW_FORMULA:->:*
        - define NEW_FORMULA:->:<[EL]>
        - foreach next


      - if <[EL].is_decimal>:
        - define NEW_FORMULA:->:<[EL]>
        - foreach next

      # Get the previous element
      - define LAST <[NEW_FORMULA].last.if_null[NULL]>

      - if <[EL].equals[(]>:
        # Handle #() and ()() as #*() and ()*()
        - if <[LAST].is_decimal> || <[LAST].equals[)]>:
          - define NEW_FORMULA:->:*
        - define NEW_FORMULA:->:<[EL]>
        - foreach next

      # If we face a closing parenthesis, we pass the information to the next round
      - if <[EL].equals[)]>:
        - define NEW_FORMULA:->:)
        - define LAST_WAS_CLOSING true
        - foreach next

      # If the previous EL was an operator and we face either + or -
      # it means we face a number with a sign
      # > We pass the sign to the next loop and do nothing yet
      - if <[OPERATORS].contains[<[LAST]>]> && ( <[EL].equals[+]> || <[EL].equals[-]> ):
        - define NEXT_HAS_SIGN true
        - define SIGN <[EL]>
        - foreach next

      - define NEW_FORMULA:->:<[EL]>

    - definemap RESULT:
        OK: true
        RESULT: <[NEW_FORMULA]>
    - determine <[RESULT]>

apa_core_proc_math_formula_to_postfix:
  type: procedure
  debug: false
  definitions: INPUT
  data:
    precedence:
      'sin': 4
      'tan': 4
      'cos': 4
      'p': 4
      'r': 4
      '*': 3
      '/': 3
      '+': 2
      '-': 2
  script:
    - define MAP <[INPUT].proc[apa_core_proc_math_formula_split]>
    - if !<[MAP.OK]>:
      - definemap RESULT:
          OK: false
          MESSAGE: <[MAP.MESSAGE]>
      - determine <[RESULT]>
    - define FORMULA <[MAP.RESULT]>

    # Precedence map
    - define PRECEDENCE <script.data_key[DATA.PRECEDENCE]>
    # All operators EXCEPT parenthesis
    - define OPERATORS <[PRECEDENCE].keys>


    - define QUEUE <list>
    - define STACK <list>

    - foreach <[FORMULA]> as:EL:

      # Numbers
      - if <[EL].is_decimal>:
        - define QUEUE:->:<[EL]>
        - foreach next

      # Operators except parenthesis
      - if <[OPERATORS].contains[<[EL]>]>:
        # If the last element in the STACK is an operator, we check for its precedence
        - define LAST <[STACK].last.if_null[NULL]>
        - if <[OPERATORS].contains[<[LAST]>]> && <[PRECEDENCE.<[LAST]>]> >= <[PRECEDENCE.<[EL]>]>:
          # If the new item has a lower precedence than the previous item,
          # We move the previous operator from the STACK to the QUEUE
          - define QUEUE:->:<[LAST]>
          - define STACK[last]:<-
        # And we append the new operator to the STACK
        - define STACK:->:<[EL]>
        - foreach next

      # Openning parenthesis
      - if <[EL].equals[(]>:
        - define STACK:->:(
        - foreach next

      # Closing parenthesis
      - if <[EL].equals[)]>:
        # Security to prevent infinite loops in case of wrong formulas
        - define SECURITY 0
        - while <[SECURITY]> < 100:
          - define SECURITY:++

          # Get the last element in the STACK
          - define LAST <[STACK].last.if_null[NULL]>

          # If there's no more element in the stack but we're still in the loop,
          # parenthesis are unmatched
          - if <[LAST]> == NULL:
            - determine "<map[OK=false;MESSAGE=Mismatched parenthesis.]>"

          # When we find the closing parenthesis,
          # we remove it from the STACK and end the while loop
          - if <[LAST].equals[(]>:
            - define STACK[last]:<-
            - while stop
          # As long as the while loops, we take the last element in the STACK
          # and append it to the QUEUE
          - define QUEUE:->:<[LAST]>
          - define STACK[last]:<-
        - foreach next

    # When we've looped through all the formula,
    # we take the remaining elements of the stack and append them to the QUEUE
    - foreach <[STACK].reverse> as:EL:
      - define QUEUE:->:<[EL]>

    - definemap RESULT:
        OK: true
        RESULT: <[QUEUE]>
    - determine <[RESULT]>

apa_core_proc_math_formula_calculate:
  type: procedure
  debug: false
  definitions: INPUT
  script:
    - define MAP <[INPUT].proc[apa_core_proc_math_formula_to_postfix]>
    - if !<[MAP.OK]>:
      - definemap RESULT:
          OK: false
          MESSAGE: <[MAP.MESSAGE]>
      - determine <[RESULT]>
    - define FORMULA <[MAP.RESULT]>

    # All operators excepts single-input-operators that's handled differently
    - define OPERATORS <list[p|/|*|-|+]>
    # All single-input-operators
    - define S_OPERATORS <list[sin|tan|cos|r]>
    # The STACK of elements to be parsed and already parsed
    - define STACK <list>

    - foreach <[FORMULA]> as:EL:
      # Handle decimals
      # not much to think about, simply add to stack
      - if <[EL].is_decimal>:
        - define STACK:->:<[EL]>
        - foreach next
      # Handle single-input-operators
      # Square roots, sin, tan, …
      # They only need to mess with the following value
      - if <[S_OPERATORS].contains[<[EL]>]>:
        - define AFTER <[STACK].last>
        - define STACK[last]:<-
        - choose <[EL]>:
          - case tan:
            - define NEW_EL <[AFTER].tan>
          - case cos:
            - define NEW_EL <[AFTER].cos>
          - case sin:
            - define NEW_EL <[AFTER].sin>
          - case r:
            - define NEW_EL <[AFTER].sqrt>
        - define STACK:->:<[NEW_EL]>
        - foreach next
      - if <[OPERATORS].contains[<[EL]>]>:
        - define AFTER <[STACK].last.if_null[NULL]>
        - if <[AFTER]> == NULL:
          - definemap RESULT:
              OK: false
              MESSAGE: Too many operators.
          - determine <[RESULT]>
        - define STACK[last]:<-
        - define BEFORE <[STACK].last.if_null[NULL]>
        - if <[BEFORE]> == NULL:
          - definemap RESULT:
              OK: false
              MESSAGE: Too many operators.
          - determine <[RESULT]>
        - define STACK[last]:<-
        - choose <[EL]>:
          - case *:
            - define NEW_EL <[BEFORE].mul[<[AFTER]>]>
          - case /:
            - define NEW_EL <[BEFORE].div[<[AFTER]>]>
          - case +:
            - define NEW_EL <[BEFORE].add[<[AFTER]>]>
          - case -:
            - define NEW_EL <[BEFORE].sub[<[AFTER]>]>
          - case p:
            - define NEW_EL <[BEFORE].power[<[AFTER]>]>
        - define STACK:->:<[NEW_EL]>
        - foreach next
      # If no type matched, we have unhandled chars
      - definemap RESULT:
          OK: false
          MESSAGE: Formula contains unhandled characters. (<[EL]>)
      - determine <[RESULT]>
    - definemap RESULT:
        OK: true
        RESULT: <[STACK]>
    - determine <[RESULT]>

casjasakjhskajhksjahskjh:
  type: command
  name: c
  debug: false
  description: Does something
  usage: /c
  script:
    - announce to_console --------------------
    - announce to_console "<context.args.unseparated> ="
    - announce to_console <map[formula=<context.args.space_separated>].proc[apademide].context[math.calc]>
    - announce to_console --------------------